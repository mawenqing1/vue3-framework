{
  "version": 3,
  "sources": ["../src/index.ts", "../../shared/src/index.ts", "../src/effect.ts", "../src/baseHandler.ts", "../src/reactive.ts", "../src/computed.ts", "../src/watch.ts", "../src/ref.ts"],
  "sourcesContent": ["export { reactive } from \"./reactive\";\nexport { effect } from \"./effect\";\nexport { computed } from \"./computed\";\nexport { watch } from \"./watch\";\nexport { ref, toRef, toRefs, proxyRefs } from \"./ref\";", "export const isObj = (value) => {\n    return typeof value === 'object' && value !== null\n}\nexport const isFunction = (value) => {\n    return typeof value === 'function'\n}", "export let activeEffect = undefined;\n\nfunction cleanEffect(effect) {\n    let deps = effect.deps;\n    for (let i = 0; i < deps.length; i++) {\n        deps[i].delete(effect)\n    }\n    effect.deps.length = 0;\n}\n\nexport class ReactiveEffect {\n    public active = true;\n    public parent = null;\n    public deps = [];\n    constructor(public fn, public scheduler?) {\n        this.fn = fn;\n    }\n    run() {\n        if (!this.active) {\n            return this.fn()\n        } else {\n            try {\n                this.parent = activeEffect;\n                activeEffect = this;\n                cleanEffect(this);\n                return this.fn()\n            } finally {\n                activeEffect = this.parent;\n                this.parent = null;\n            }\n        }\n    };\n    stop() {\n        if (this.active) {\n            this.active = false;\n            cleanEffect(this)\n        }\n    }\n};\n\n//map {object: {name:[effect, effect], age:[effect,effect]}}\nconst targetMap = new WeakMap();\nexport function trigger(target, key, value) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n        return;\n    }\n    let effects = depsMap.get(key);\n    triggerEffects(effects)\n};\n\nexport function triggerEffects(effects) {\n    if (effects) {\n        effects = new Set(effects);\n        effects && effects.forEach(effect => {\n            if (effect !== activeEffect) {\n                if (effect.scheduler) {\n                    effect.scheduler()\n                } else {\n                    effect.run();\n                }\n            }\n        });\n    }\n}\n\nexport function track(target, key) {\n    if (activeEffect) {\n        let depsMap = targetMap.get(target);\n        if (!depsMap) {\n            targetMap.set(target, (depsMap = new Map()));\n        }\n        let deps = depsMap.get(key);\n        if (!deps) {\n            depsMap.set(key, (deps = new Set()));\n        }\n        trackEffects(deps)\n    }\n}\n\nexport function trackEffects(deps) {\n    let shouldTrack = !deps.has(activeEffect);\n    if (shouldTrack) {\n        deps.add(activeEffect);\n        activeEffect.deps.push(deps);\n    }\n}\n\nexport function effect(fn, options: any = {}) {\n    const _effect = new ReactiveEffect(fn, options.scheduler);\n    _effect.run();\n    const runner = _effect.run.bind(_effect);\n    runner.effect = _effect;\n    return runner\n};", "import { isObj } from \"@vue/shared\";\nimport { track, trigger } from \"./effect\";\nimport { reactive } from \"./reactive\";\n\nexport const enum ReactiveFlags {\n    IS_REACTIVE = '_v_isReactive'\n}\n\nexport function isReactive(value) {\n    return value && value[ReactiveFlags.IS_REACTIVE]\n}\n\nexport const baseHandler = {\n    get(target, key, receiver) {\n        if(key === ReactiveFlags.IS_REACTIVE) {\n            return true\n        }\n        track(target, key)\n        let res = Reflect.get(target, key, receiver);\n        if(isObj(res)) {\n            return reactive(res)\n        }\n        return res\n    },\n    set(target, key, value, receiver) {\n        let oldValue = target[key];\n        if(oldValue !== value) {\n           let result = Reflect.set(target, key, value, receiver);\n           trigger(target, key, value);\n           return result\n        }\n    }\n}", "import { isObj } from \"@vue/shared\";\nimport {baseHandler, ReactiveFlags} from \"./baseHandler\";\n\nconst reactiveMap = new WeakMap();\n\nexport function reactive(target) {\n    if(!isObj(target)) {\n        return target\n    }\n    if(target[ReactiveFlags.IS_REACTIVE]) {\n        return target\n    }\n    const existing = reactiveMap.get(target);\n    if(existing) {\n        return existing\n    }\n\n    const proxy = new Proxy(target, baseHandler);\n    reactiveMap.set(target, proxy)\n    return proxy;\n}", "import { isFunction } from \"@vue/shared\";\nimport { ReactiveEffect, activeEffect, trackEffects, triggerEffects } from \"./effect\";\n\nexport function computed(getterOrOptions) {\n    let isGetter = isFunction(getterOrOptions);\n    let getter;\n    let setter;\n    const fn = () => console.warn('computed is readonly');\n    if(isGetter) {\n        getter = getterOrOptions;\n        setter = fn\n    } else {\n        getter = getterOrOptions.get;\n        setter = getterOrOptions.set || fn\n    }\n    \n    return new ComputedRefImpl(getter, setter)\n}\n\nclass ComputedRefImpl {\n    private _value;\n    private _dirty = true;\n    public effect;\n    public deps;\n    private __v_isRef = true;\n    constructor(getter, public setter) {\n        this.effect = new ReactiveEffect(getter, () => {\n            if(!this._dirty) {\n                this._dirty = true;\n                triggerEffects(this.deps)\n            }\n        })\n    }\n    get value() {\n        if(activeEffect) {\n            trackEffects(this.deps || (this.deps = new Set()))\n        }\n\n        if(this._dirty) {\n            this._dirty = false;\n            this._value = this.effect.run();\n        }\n        return this._value;\n    }\n    set value(newValues) {\n        this.setter(newValues);\n    }\n}", "import { ReactiveEffect } from \"./effect\";\nimport { isReactive } from \"./baseHandler\";\nimport { isFunction, isObj } from \"@vue/shared\";\n\nfunction traversal(value, set = new Set()) {\n    if(!isObj(value)) {\n        return value\n    }\n    if(set.has(value)) {\n        return value\n    }\n    set.add(value);\n    for(let key in value) {\n        traversal(value[key], set)\n    }\n    return value\n}\n\nexport  function watch(source, cb) {\n    let get;\n    if(isReactive(source)) {\n        get = () => traversal(source);\n    } else if(isFunction(source)) {\n        get = source;\n    };\n    let oldValue;\n    let cleanup;\n    const onCleanup = (fn) => {\n        cleanup = fn\n    }\n    const job = () => {\n        cleanup && cleanup();\n        let newValue = effect.run();\n        cb(newValue, oldValue, onCleanup);\n        oldValue = newValue;\n    }\n    const effect = new ReactiveEffect(get, job);\n    oldValue = effect.run();\n}", "import { isObj } from \"@vue/shared\";\nimport { reactive } from \"./reactive\";\nimport { trackEffects, triggerEffects } from \"./effect\";\n\nexport function ref(value) {\n    return new RefImpl(value)\n}\n\nexport function toRef(object, key) {\n    return new ObjectRefImpl(object, key)\n}\n\nexport function toRefs(object) {\n    let result = {};\n    for(let key in object) {\n        result[key] = toRef(object, key)\n    };\n    return result\n}\n\nexport function proxyRefs(object) {\n    return new Proxy(object, {\n        get(target, key, receiver) {\n            let result = Reflect.get(target, key, receiver);\n            return result.__v_isRef ? result.value : result\n        },\n        set(target,key,value,receiver) {\n            if(target[key].__v_isRef) {\n                target[key].value = value;\n                return true\n            }\n            return Reflect.set(target,key,value,receiver)\n        }\n    })\n}\n\nexport function toReactive(value) {\n    return isObj(value) ? reactive(value) : value\n}\n\nclass RefImpl {\n    private _value;\n    private dep\n    private __v_isRef = true\n    constructor(public rawValue) {\n        this._value = toReactive(rawValue)\n    }\n\n    get value() {\n        trackEffects(this.dep || (this.dep = new Set))\n        return this._value\n    }\n\n    set value(newValue) {\n        if(newValue != this.rawValue) {\n            this._value = toReactive(newValue)\n            this.rawValue = newValue;\n            triggerEffects(this.dep)\n        }\n    }\n}\n\nclass ObjectRefImpl {\n    private __v_isRef = true\n    constructor(public object, public key) {}\n    get value() {\n        return this.object[this.key]\n    }\n    set value(newValue) {\n        this.object[this.key] = newValue;\n    }\n}"],
  "mappings": "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",
  "names": ["effect", "effect", "effect"]
}
