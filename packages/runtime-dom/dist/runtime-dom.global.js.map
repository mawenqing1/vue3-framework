{
  "version": 3,
  "sources": ["../src/index.ts", "../../shared/src/index.ts", "../../runtime-core/src/createVNode.ts", "../../runtime-core/src/h.ts", "../../runtime-core/src/renderer.ts", "../src/nodeOps.ts", "../src/patch-prop/patchClass.ts", "../src/patch-prop/patchStyle.ts", "../src/patch-prop/patchEvent.ts", "../src/patch-prop/patchAttr.ts", "../src/patchProp.ts"],
  "sourcesContent": ["import { createRenderer } from \"@vue/runtime-core\";\nimport { nodeOps } from \"./nodeOps\";\nimport { patchProp } from \"./patchProp\";\n\nconst renderOptions = {patchProp, ...nodeOps}\n\nexport function render(vnode, container) {\n    let { render } = createRenderer(renderOptions)\n\n    return render(vnode, container)\n}\n\nexport * from '@vue/runtime-core'", "export const isObj = (value) => {\n    return typeof value === 'object' && value !== null\n}\nexport const isFunction = (value) => {\n    return typeof value === 'function'\n}\nexport const isString = (value) => {\n    return typeof value === 'string'\n}\nexport const isArray = Array.isArray;\n\nexport const isNumber = (value) => {\n    return typeof value === 'number'\n}", "import { isArray, isString } from \"@vue/shared\";\n\nexport const Text = Symbol('Text');\n\nexport function isVNode(value) {\n    return value.__v_isVNode;\n}\n\nexport function isSameVNode(v1, v2) {\n    return v1.type === v2.type && v1.key === v2.key;\n}\n\nexport function createVNode(type, props = null, children = null) {\n\n    let shapeFlag = isString(type) ? ShapeFlags.ELEMENT : 0;\n    \n    const vnode = {\n        __v_isVNode: true,\n        type,\n        props,\n        children,\n        key: props && props.key,\n        el: null,\n        shapeFlag\n    }\n\n    if(children) {\n        let temp = 0;\n        if(isArray(children)) {\n            temp = ShapeFlags.ARRAY_CHILDREN;\n        } else {\n            children = String(children);\n            temp = ShapeFlags.TEXT_CHILDREN;\n        }\n        vnode.shapeFlag |= temp;\n    }\n    \n    return vnode;\n}\n\nexport const enum ShapeFlags {\n    ELEMENT = 1,\n    FUNCTIONAL_COMPONENT = 1 << 1,\n    STATEFUL_COMPONENT = 1 << 2,\n    TEXT_CHILDREN = 1 << 3,\n    ARRAY_CHILDREN = 1 << 4,\n    SLOTS_CHILDREN = 1 << 5,\n    TELEPORT = 1 << 6,\n    SUSPENSE = 1 << 7,\n    COMPONENT_SHOULD_KEEP_ALIVE = 1 << 8,\n    COMPONENT_KEPT_ALIVE = 1 << 9,\n    COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT\n}", "import { isArray, isObj } from \"@vue/shared\";\nimport { isVNode, createVNode } from \"./createVNode\";\n\nexport function h(type, propsOrChildren, children) {\n    const l = arguments.length;\n\n    if(l === 2) {\n        if(isObj(propsOrChildren) && !isArray(propsOrChildren)) {\n            if(isVNode(propsOrChildren)) {\n                return createVNode(type, null, [propsOrChildren])\n            }\n            return createVNode(type, propsOrChildren)\n        } else {\n            return createVNode(type, null, propsOrChildren)\n        }\n\n    } else {\n        if(l === 3 && isVNode(children)) {\n            children = [children]\n        } else if(l > 3) {\n            children = Array.prototype.slice.call(arguments, 2)\n        }\n        return createVNode(type, propsOrChildren, children)\n    }\n}", "import { isNumber, isString } from \"@vue/shared\";\nimport { ShapeFlags, Text, createVNode, isSameVNode } from \"./createVNode\";\n\nfunction getSequence(arr) {\n    let len = arr.length;\n    let result = [0];\n    let p = new Array(len).fill(0);\n    let lastIndex;\n    let start\n    let end\n    let middle\n    for (let i = 0; i < len; i++) {\n        const arrI = arr[i];\n        if (arrI !== 0) {\n            lastIndex = result[result.length - 1];\n            if (arr[lastIndex] < arrI) {\n                p[i] = lastIndex;\n                result.push(i);\n                continue\n            }\n            //\u4E8C\u5206\u67E5\u627E\n            start = 0;\n            end = result.length - 1;\n            while (start < end) {\n                middle = Math.floor((start + end) / 2);\n                if (arr[result[middle]] < arrI) {\n                    start = middle + 1;\n                } else {\n                    end = middle;\n                }\n            }\n            if (arrI < arr[result[end]]) {\n                p[i] = result[end - 1]\n                result[end] = i\n            }\n        }\n    }\n    //\u5012\u53D9\u8FFD\u6EAF\n    let i = result.length;\n    let last = result[i - 1];\n\n    while (i-- > 0) {\n        result[i] = last;\n        last = p[last];\n    }\n\n    return result\n}\n\nexport function createRenderer(options: any) {\n\n    let {\n        createElement: hostCreateElement,\n        createTextNode: hostCreateTextNode,\n        insert: hostInsert,\n        remove: hostRemove,\n        querySelector: hostQuerySelector,\n        parentNode: hostParentNode,\n        //\u83B7\u53D6\u5144\u5F1F\u8282\u70B9\n        nextSibling: hostNextSibling,\n        setText: hostSetText,\n        setElementText: hostSetElementText,\n        patchProp: hostPatchProp,\n    } = options;\n\n    function normalize(children, i) {\n        if (isNumber(children[i]) || isString(children[i])) {\n            children[i] = createVNode(Text, null, children[i])\n        }\n        return children[i]\n    }\n\n    function mountChildren(children, container) {\n\n        for (let i = 0; i < children.length; i++) {\n            let child = normalize(children, i);\n            patch(null, child, container)\n        }\n    }\n\n    function patchProps(oldProps, newProps, el) {\n        if (oldProps == null) oldProps = {}\n        if (newProps == null) newProps = {}\n        for (let key in newProps) {\n            let prev = oldProps[key];\n            let next = newProps[key];\n            if (prev !== next) {\n                hostPatchProp(el, key, prev, next)\n            }\n        }\n\n        for (let key in oldProps) {\n            if (!newProps.hasOwnProperty(key)) {\n                hostPatchProp(el, key, oldProps[key], null)\n            }\n        }\n    }\n\n    function mountElement(vnode, container, anchor) {\n        let { type, props, children, shapeFlag } = vnode;\n        let el = vnode.el = hostCreateElement(type);\n\n        if (props) {\n            patchProps(null, props, el)\n        }\n\n        if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n            hostSetElementText(el, children)\n        }\n        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n            mountChildren(children, el);\n        }\n\n        hostInsert(el, container, anchor);\n    }\n\n    function processText(n1, n2, container) {\n        if (n1 === null) {\n            hostInsert(n2.el = hostCreateTextNode(n2.children, container), container);\n        }\n    }\n\n    function unmountChildren(children) {\n        children.forEach(el => {\n            unmount(el)\n        })\n    }\n\n    function patchKeyedChildren(c1, c2, el) {\n        let i = 0;\n        let e1 = c1.length - 1;\n        let e2 = c2.length - 1;\n\n        while (i <= e1 && i <= e2) {\n            const n1 = c1[i];\n            const n2 = c2[i];\n            if (isSameVNode(n1, n2)) {\n                patch(n1, n2, el)\n            } else {\n                break\n            }\n            i++;\n        }\n\n        while (i <= e1 && i <= e2) {\n            const n1 = c1[e1];\n            const n2 = c2[e2];\n            if (isSameVNode(n1, n2)) {\n                patch(n1, n2, el)\n            } else {\n                break\n            }\n            e1--;\n            e2--;\n        }\n\n        if (i > e1) {\n            if (i <= e2) {\n                while (i <= e2) {\n                    const nextPos = e2 + 1;\n                    let anchor = c2.length <= nextPos ? null : c2[nextPos].el;\n                    patch(null, c2[i], el, anchor)\n                    i++\n                }\n            }\n        } else if (i > e2) {\n            if (i <= e1) {\n                while (i <= e1) {\n                    unmount(c1[i])\n                    i++\n                }\n            }\n        } else {\n            let s1 = i;\n            let s2 = i;\n            const keyToNewIndexMap = new Map();\n            let toBePatched = e2 - s2 + 1;\n\n            for (let i = s2; i <= e2; i++) {\n                keyToNewIndexMap.set(c2[i].key, i);\n            }\n\n            const seq = new Array(toBePatched).fill(0);\n\n            for (let i = s1; i <= e1; i++) {\n                const oldVNode = c1[i];\n                let newIndex = keyToNewIndexMap.get(oldVNode.key);\n                if (newIndex == null) {\n                    unmount(oldVNode)\n                } else {\n                    seq[newIndex - s2] = i + 1;\n                    patch(oldVNode, c2[newIndex], el)\n                }\n            }\n\n            let incr = getSequence(seq)\n            let j = incr.length - 1\n\n            for (let i = toBePatched - 1; i >= 0; i++) {\n                const currentIndex = s2 + i;\n                const child = c2[currentIndex]\n                const anchor = currentIndex + 1 < c2.length ? c2[currentIndex + 1].el : null;\n                if (child.el == null) {\n                    patch(null, child, el, anchor)\n                } else {\n                    if (i !== incr[j]) {\n                        hostInsert(child.el, el, anchor)\n                    } else {\n                        j--;\n                    }\n                }\n            }\n        }\n    }\n\n    function patchChildren(n1, n2, el) {\n        let c1 = n1.children;\n        let c2 = n2.children;\n        const prevShapeFlag = n1.shapeFlag;\n        const shapeFlag = n2.shapeFlag;\n\n        if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n            if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n                unmountChildren(c1);\n            }\n            if (c1 !== c2) {\n                hostSetElementText(el, c2)\n            }\n        } else {\n            if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n                if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n                    patchKeyedChildren(c1, c2, el)\n                } else {\n                    unmountChildren(c1);\n                }\n            } else {\n                if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n                    hostSetElementText(el, '')\n                }\n                if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n                    mountChildren(c2, el)\n                }\n            }\n        }\n    }\n\n    function patchElement(n1, n2) {\n        let el = n2.el = n1.el;\n        let oldProps = n1.props;\n        let newProps = n2.props;\n        patchProps(oldProps, newProps, el)\n        patchChildren(n1, n2, el);\n    }\n\n    function processElement(n1, n2, container, anchor) {\n        if (n1 == null) {\n            mountElement(n2, container, anchor);\n        } else {\n            patchElement(n1, n2);\n        }\n    }\n\n    function unmount(n1) {\n        hostRemove(n1.el);\n    }\n\n    function patch(n1, n2, container, anchor = null) {\n\n        if (n1 && !isSameVNode(n1, n2)) {\n            unmount(n1);\n            n1 = null;\n        }\n\n        const { type, shapeFlag } = n2;\n\n        switch (type) {\n            case Text:\n                processText(n1, n2, container);\n                break;\n            default:\n                if (shapeFlag & ShapeFlags.ELEMENT) {\n                    processElement(n1, n2, container, anchor);\n                }\n        }\n    }\n\n    function render(vnode, container) {\n\n        if (vnode == null) {\n            if (container._vnode) {\n                unmount(container._vnode);\n            }\n        } else {\n            patch(container._vnode || null, vnode, container)\n        }\n\n        container._vnode = vnode;\n\n    }\n\n    return {\n        render\n    }\n}", "export const nodeOps = {\n    createElement(tagName) {\n        return document.createElement(tagName);\n    },\n    createTextNode(text) {\n        return document.createTextNode(text);\n    },\n    insert(element, parent, anchor = null) {\n        parent.insertBefore(element, anchor);\n    },\n    remove(child) {\n        const parent = child.parentNode;\n        if (parent) {\n            parent.removeChild(child);\n        }\n    },\n    querySelector(selectors) {\n        return document.querySelector(selectors);\n    },\n    parentNode(node) {\n        return node.parentNode;\n    },\n    //\u83B7\u53D6\u5144\u5F1F\u8282\u70B9\n    nextSibling(node) {\n        return node.nextSibling;\n    },\n    setText(element, text) {\n        element.nodeValue = text;\n    },\n    setElementText(element, text) {\n        element.textContent = text;\n    }\n}", "export function patchClass(el, nextValue) {\n    if(nextValue == null) {\n        el.removeAttribute('class');\n    } else {\n        el.className = nextValue\n    }\n}", "export function patchStyle(el, preValue, nextValue) {\n    if(preValue == null) preValue = {};\n    if(nextValue == null) nextValue = {};\n    const style = el.style;\n    for(let key in nextValue) {\n        style[key] = nextValue[key];\n    }\n\n    if(preValue) {\n        for(let key in preValue) {\n            if(nextValue[key] == null) {\n                style[key] = null;\n            }\n        }\n    }\n}", "function createInvoker(fn) {\n    const invoker = () => {\n        invoker.value()\n    }\n    invoker.value = fn\n    return invoker\n}\n\nexport function patchEvent(el, eventName, nextValue) {\n    const invokers = el._vei || (el._vei = {});\n    const exitingInvoker = invokers[eventName];\n    if(exitingInvoker && nextValue) {\n        exitingInvoker.value = nextValue;\n    } else {\n        const eName = eventName.slice(2).toLowerCase();\n        if(nextValue) {\n            const invoker = createInvoker(nextValue);\n            invokers[eventName] = invoker;\n            el.addEventListener(eName, invoker);\n        } else if(exitingInvoker) {\n            el.removeEventListener(eName, exitingInvoker);\n            invokers[eventName] = null;\n        }\n    }\n}", "export function patchAttr(el, key, nextValue) {\n    if(nextValue == null) {\n        el.removeAttribute(key);\n    } else {\n        el.setAttribute(key, nextValue);\n    }\n}", "import { patchClass } from \"./patch-prop/patchClass\"\nimport { patchStyle } from \"./patch-prop/patchStyle\"\nimport { patchEvent } from \"./patch-prop/patchEvent\"\nimport { patchAttr } from \"./patch-prop/patchAttr\"\n\nexport const patchProp = (el, key, preValue, nextValue) => {\n    if(key === 'class') {\n        patchClass(el, nextValue)\n    } else if(key === 'style') {\n        patchStyle(el, preValue, nextValue)\n    } else if(/on[^a-z]/.test(key)) {\n        patchEvent(el, key, nextValue)\n    } else {\n        patchAttr(el, key, nextValue)\n    }\n}"],
  "mappings": "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",
  "names": ["ShapeFlags", "i", "render", "render"]
}
